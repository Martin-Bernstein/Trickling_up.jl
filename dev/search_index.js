var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Trickling_up","category":"page"},{"location":"#Trickling_up","page":"Home","title":"Trickling_up","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Trickling_up. This documentation describes the purpose and mathematical foundations for each of the functions used to simulate the models (defined in /src/model_simulators.jl, /src/solver.jl and /src/simpson.jl).","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Trickling_up]","category":"page"},{"location":"#Trickling_up.duration-Tuple{Any}","page":"Home","title":"Trickling_up.duration","text":"Calculates the duration of total consumption using the \"simpson\" integration function.\n\n\n\n\n\n","category":"method"},{"location":"#Trickling_up.simpson-Tuple{Any, Any}","page":"Home","title":"Trickling_up.simpson","text":"Implements Simpson's rule in order to integrate over the paths, using the auxiliary weights function simpson_weights.\n\n\n\n\n\n","category":"method"},{"location":"#Trickling_up.simpson_weights-Tuple{Any}","page":"Home","title":"Trickling_up.simpson_weights","text":"Auxiliary function to implement Simpson's rule, in order to integrate over the paths of consumption, to obtain the duration of total consumption int tC_t  int C_t.\n\n\n\n\n\n","category":"method"},{"location":"#Trickling_up.simulate_baseline-NTuple{4, Any}","page":"Home","title":"Trickling_up.simulate_baseline","text":"Simulates the baseline model. The model in the paper is designed to study the distribution of wealth between quantile groups over time. The function returns the paths of assets for each group and the path of aggregate consumption, across the simulation.\n\nArguments: a0 is a vector of the groups' excess savings' initial shares in GDP. m is a vector of each group's respective marginal propensity to consume. theta is a vector with the proportion of national income earned by each group. ts is the time-series for which the model is to be simulated. ge is a boolean which switches general equilibrium effects on or off, enabling analysis of partial and general equilibrium separately.\n\n\n\n\n\n","category":"method"},{"location":"#Trickling_up.simulate_monetary-NTuple{6, Any}","page":"Home","title":"Trickling_up.simulate_monetary","text":"This function extends the model to include a monetary policy response. a0, m, theta, and ts are as in simulatebaseline. phi is the coefficient on output in the monetary authorities policy function: the paper assumes that real rates are set according to r_t=phi Y_t. sigma is households elasticity of intertemporal substitution.\n\n\n\n\n\n","category":"method"},{"location":"#Trickling_up.simulate_re-NTuple{4, Any}","page":"Home","title":"Trickling_up.simulate_re","text":"This function extends the baseline model to include rational expectations of future income. a0, m, theta, and ts are as before. The function returns the path of assets and consumption.\n\n\n\n\n\n","category":"method"},{"location":"#Trickling_up.solver-Tuple{Any, Any}","page":"Home","title":"Trickling_up.solver","text":"(Very) lightweight solver for linear rational expectations models in continuous time\n\nSuppose our model is given by the linear ODE\n\n    beginpmatrixdotxdotyendpmatrix\n    =\n    beginpmatrixA_xx  A_xy  A_yx  A_yyendpmatrix\n    beginpmatrixxyendpmatrix\n\nwhere x is a predetermined `state' vector of length N, y is vector of 'jump' variables, and the four blocks A form a matrix mathbfA. For there to be a unique solution for y given the state x, there must be N stable eigenvalues (i.e. with negative real part) of mathbfA.\n\nLet mathbfA = QUQ be the Schur decomposition of mathbfA, where Q is unitary and U is upper triangular. Assuming that this is decomposition is made such that the stable eigenvalues of U are at the top left, we can write:\n\n    U=beginpmatrixU_ssU_su0U_uuendpmatrix\n    hspace1cm\n    Q=beginpmatrixQ_xs  Q_xu  Q_ys  Q_yuendpmatrix\n\nwhere the N-by-N upper left block U_ss maps the stable subspace to itself, the N-by-N Q_xs maps the stable subspace to x, etc.\n\nGiven any state x, we can obtain the rotated stable state by solving s = Q_xs^-1*x. Then dots = U_ss*s, and dotx = Q_xs*dots = Q_xs*U_ss*Q_xs^-1.  The jump variables y can be obtained from s by y = Q_yx*s = Q_yx*Q_xs^-1*x.\n\nSumming up, our model will have law of motion\n\ndotx = B*x\nhspace1cm\ny = F*x\n\nwhere B = Q_xs*U_ss*Q_xs^-1 and F = Q_yx*Q_xs^-1.\n\n\n\n\n\n","category":"method"}]
}
